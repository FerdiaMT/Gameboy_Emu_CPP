
#include <fstream>
#include <stdio.h>
#include <iostream>
#include <cstdint>
#include <SDL3/sdl.h>
#include <string> 
#include <thread>
#include <chrono>
#include "Gameboy.h"



bool running = true;

SDL_Window* window;
SDL_Renderer* renderer;
SDL_Texture* texture;


SDL_Window* window2;
SDL_Renderer* renderer2;

SDL_Window* window3;
SDL_Renderer* renderer3;

const int WIDTH = 160;
const int HEIGHT = 144;
const int SCALE = 5;


uint8_t pixelState[160][144]{}; // for now this can be 0,1,2,3,4
bool keyboardState[6]{ true,true,true,true,true,true };

/*
Todo:

	OAM transfer
	STAT reg
	replace view with read in cpu
*/
uint8_t bootRO[256] = {
	0x31, 0xFE, 0xFF, 0xAF, 0x21, 0xFF, 0x9F, 0x32, 0xCB, 0x7C, 0x20, 0xFB, 0x21, 0x26, 0xFF, 0x0E,
0x11, 0x3E, 0x80, 0x32, 0xE2, 0x0C, 0x3E, 0xF3, 0xE2, 0x32, 0x3E, 0x77, 0x77, 0x3E, 0xFC, 0xE0,
0x47, 0x11, 0x04, 0x01, 0x21, 0x10, 0x80, 0x1A, 0xCD, 0x95, 0x00, 0xCD, 0x96, 0x00, 0x13, 0x7B,
0xFE, 0x34, 0x20, 0xF3, 0x11, 0xD8, 0x00, 0x06, 0x08, 0x1A, 0x13, 0x22, 0x23, 0x05, 0x20, 0xF9,
0x3E, 0x19, 0xEA, 0x10, 0x99, 0x21, 0x2F, 0x99, 0x0E, 0x0C, 0x3D, 0x28, 0x08, 0x32, 0x0D, 0x20,
0xF9, 0x2E, 0x0F, 0x18, 0xF3, 0x67, 0x3E, 0x64, 0x57, 0xE0, 0x42, 0x3E, 0x91, 0xE0, 0x40, 0x04,
0x1E, 0x02, 0x0E, 0x0C, 0xF0, 0x44, 0xFE, 0x90, 0x20, 0xFA, 0x0D, 0x20, 0xF7, 0x1D, 0x20, 0xF2,
0x0E, 0x13, 0x24, 0x7C, 0x1E, 0x83, 0xFE, 0x62, 0x28, 0x06, 0x1E, 0xC1, 0xFE, 0x64, 0x20, 0x06,
0x7B, 0xE2, 0x0C, 0x3E, 0x87, 0xE2, 0xF0, 0x42, 0x90, 0xE0, 0x42, 0x15, 0x20, 0xD2, 0x05, 0x20,
0x4F, 0x16, 0x20, 0x18, 0xCB, 0x4F, 0x06, 0x04, 0xC5, 0xCB, 0x11, 0x17, 0xC1, 0xCB, 0x11, 0x17,
0x05, 0x20, 0xF5, 0x22, 0x23, 0x22, 0x23, 0xC9, 0xCE, 0xED, 0x66, 0x66, 0xCC, 0x0D, 0x00, 0x0B,
0x03, 0x73, 0x00, 0x83, 0x00, 0x0C, 0x00, 0x0D, 0x00, 0x08, 0x11, 0x1F, 0x88, 0x89, 0x00, 0x0E,
0xDC, 0xCC, 0x6E, 0xE6, 0xDD, 0xDD, 0xD9, 0x99, 0xBB, 0xBB, 0x67, 0x63, 0x6E, 0x0E, 0xEC, 0xCC,
0xDD, 0xDC, 0x99, 0x9F, 0xBB, 0xB9, 0x33, 0x3E, 0x3C, 0x42, 0xB9, 0xA5, 0xB9, 0xA5, 0x42, 0x3C,
0x21, 0x04, 0x01, 0x11, 0xA8, 0x00, 0x1A, 0x13, 0xBE, 0x20, 0xFE, 0x23, 0x7D, 0xFE, 0x34, 0x20,
0xF5, 0x06, 0x19, 0x78, 0x86, 0x23, 0x05, 0x20, 0xFB, 0x86, 0x20, 0xFE, 0x3E, 0x01, 0xE0, 0x50
};

uint8_t headerRO[0x30] = {
	0xCE, 0xED, 0x66 ,0x66 ,0xCC ,0x0D ,0x00 ,0x0B, 0x03 ,0x73, 0x00 ,0x83 ,0x00,0x0C,0x00, 0x0D,
	0x00, 0x08 ,0x11 ,0x1F ,0x88 ,0x89, 0x00, 0x0E, 0xDC ,0xCC ,0x6E ,0xE6 ,0xDD, 0xDD, 0xD9 ,0x99,
	0xBB, 0xBB, 0x67 ,0x63, 0x6E, 0x0E ,0xEC ,0xCC ,0xDD ,0xDC, 0x99 ,0x9F, 0xBB, 0xB9, 0x33, 0x3E
};



void setupSDL()
{
	if (SDL_Init(SDL_INIT_VIDEO) < 0)
	{
		std::cerr << "SDL could not initialize" << SDL_GetError();
		return;
	}

	window = SDL_CreateWindow("DMG", WIDTH * 6, HEIGHT * 6, 0);
	if (!window)
	{
		std::cerr << "Window couldnt be created " << SDL_GetError();
		return;
	}

	renderer = SDL_CreateRenderer(window, nullptr);
	if (!renderer)
	{
		std::cerr << "Renderer couldnt be created " << SDL_GetError();
		SDL_Quit;
		return;
	}

	texture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_RGBA8888, SDL_TEXTUREACCESS_STREAMING, 160, 144);

	if (!texture)
	{
		std::cerr << "texture couldnt be created " << SDL_GetError();
		SDL_Quit;
		return;
	}

}

int main()
{
	setupSDL();
	Gameboy gb;
	if (!gb.loadROM("pokemonSilver.gbc"))
	{
		std::cout << "COULDNT FIND ROM";
	}

	SDL_Event event;

	int frameCount = 0;
	auto lastTime = std::chrono::high_resolution_clock::now();
	auto lastFrameTime = std::chrono::high_resolution_clock::now();
	const double TARGET_FRAME_TIME = 16.67; //1000ms / 60 - so this makes 60fps

	while (running)
	{
		auto frameStart = std::chrono::high_resolution_clock::now();

		while (SDL_PollEvent(&event))
		{
			if (event.type == SDL_EVENT_QUIT)
			{
				running = false;
			}
			else if (event.type == SDL_EVENT_KEY_DOWN)
			{
				gb.input.keyDown(event.key.scancode);
			}
			else if (event.type == SDL_EVENT_KEY_UP)
			{
				gb.input.keyUp(event.key.scancode);
			}
		}

		for (int i = 0; i < 70224; i += gb.cpu.cycles)
		{
			gb.step();
		}

		SDL_UpdateTexture(texture, nullptr, gb.ppu.framebuffer, 160 * sizeof(uint32_t));
		SDL_RenderClear(renderer);
		SDL_RenderTexture(renderer, texture, nullptr, nullptr);
		SDL_RenderPresent(renderer);


		frameCount++;
		auto now = std::chrono::high_resolution_clock::now();
		auto elapsed = std::chrono::duration_cast<std::chrono::seconds>(now - lastTime).count();
		if (elapsed >= 1)
		{
			std::cout << "FPS: " << frameCount << std::endl;
			frameCount = 0;
			lastTime = now;
		}

		auto frameEnd = std::chrono::high_resolution_clock::now();
		double frameTime = std::chrono::duration<double, std::milli>(frameEnd - frameStart).count();

		if (frameTime < TARGET_FRAME_TIME)
		{
			SDL_Delay(static_cast<Uint32>(TARGET_FRAME_TIME - frameTime));
		}
	}
	SDL_DestroyTexture(texture);
	SDL_DestroyRenderer(renderer);
	SDL_DestroyWindow(window);
	SDL_Quit();
	return 0;
}